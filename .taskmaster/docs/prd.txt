## 느리게 나이들기(Slow-Aging AI) MVP PRD

### 1. 제품 개요

**제품명:** 느리게 나이들기 (Slow-Aging AI)

**설명:** 사용자가 음식 사진을 업로드(촬영/갤러리)하면 AI가 음식을 인식하고, 사전 정의된 저속노화 규칙에 따라 '노화 지수(시간 단위)'를 산출해 재미있고 가벼운 피드백과 함께 보여주는 모바일 앱.

**핵심 컨셉:** 의학적 정확성보다 직관적·상징적 수치로 동기부여. cal.ai 스타일의 간결한 분석 UX + '저속노화' 콘셉트.

**타겟:** 20대 후반~40대 초반, 건강/자기관리 관심 사용자, 트렌드 선호, 가벼운 식단 기록 니즈.

### 2. 목표

- 사용자 참여 유도: 매일 식단 기록과 노화 지수 확인 습관화
- 저속노화 개념 확산: 음식별 노화 가감 개념 체득
- MVP 시장성 검증: 핵심 기능으로 초기 반응/리텐션 확인

### 2.1 프론트엔드 전용 범위 및 가정 (React Native 전용)

- 본 PRD는 React Native 프론트엔드만 포함합니다. 서버/백엔드는 별도 팀에서 개발합니다.
- 개발 중에는 API 응답을 FE에서 모킹하여 진행합니다. (Mock Layer)
  - `useMockApi` 플래그로 모킹 온/오프 전환
  - 기본 구조: API Client 추상화 → Mock Adapter / Real Adapter 교체 가능
- 데이터 저장은 MVP 동안 로컬 우선 전략을 사용합니다.
  - `AsyncStorage` 기반 `FoodLog` 저장/조회
  - 서버 연동 시 동기화 전략은 추후 백엔드 스펙에 맞춰 확장
- 환경설정/플래그
  - `baseURL`, `useMockApi` 등 환경 변수/설정 값을 중심으로 구성
- 이미지 업로드/분석 흐름
  - UI/흐름은 구현하되, 실제 분석 결과는 모킹으로 대체
  - 백엔드 연동 시 API Client의 Real Adapter만 교체

### 3. 주요 사용자 스토리

- 직장인: 내가 먹은 음식이 노화에 미치는 영향(±시간)을 쉽고 재미있게 알고 싶다
- 다이어터: 칼로리 대신 직관적인 지표로 동기 유지하고 싶다
- 트렌드 사용자: 나의 노화 지수를 이미지 카드로 공유하고 싶다

### 4. 핵심 기능 (MVP Scope)

F-01. AI 음식 사진 인식 및 분석
- 촬영/갤러리 업로드, 인식 실패 시 음식명 검색 입력 대체

F-02. 노화 지수 산출 및 표시
- 저속노화 규칙 기반 ±시간 산출, 위트있는 코멘트 동반
- 결과 카드: 음식 이미지/이름/지수/메시지

F-03. 일일 리포트/기록
- 일별 합산(예: 오늘 총 +1일 2시간), 캘린더/타임라인 저장
- 주간/월간 추이 간단 그래프

F-04. 소셜 공유
- 결과/리포트를 이미지 카드로 내보내기(인스타, 카카오 등)

### 5. 저속노화 규칙 (초기 단순 규칙)

가속 요인(+): AGEs(튀김/구이/가공육/탄산), 단순당, 포화/트랜스지방, 알코올
감속 요인(-): 항산화(다채색 채소/베리), 건강한 지방(아보카도/견과/올리브), 단백질(생선/콩/두부), 섬유질(통곡/채소)

예시 점수 체계:
- 아메리카노: -0.5h
- 샐러드(드레싱 제외): -2h
- 삼겹살 1인분: +5h
- 라면: +7h
- 치킨+맥주: +12h
- 딸기 한 컵: -1h

노트: MVP는 카테고리 매핑 기반의 단순 규칙 엔진부터 시작

### 6. 비기능 요구사항

- 사용성: 첫 사용에도 핵심 플로우(촬영→결과)가 직관적일 것
- 성능: 업로드 후 3~5초 내 결과
- 디자인: 젊고 트렌디, 결과 카드의 시각적 만족도 중시
- 플랫폼: iOS/Android 동시 (React Native)

### 7. 기술 스택

- FE: React Native (TypeScript)
- BE: Kotlin & Spring Boot
- DB: PostgreSQL
- AI: Google Cloud Vision(Food Detection)
- Infra: 로컬 우선, 이후 AWS/GCP

### 8. 시스템 아키텍처 개요

1) RN 앱이 사진을 `multipart/form-data`로 전송
2) Spring Boot가 수신→Vision API 호출→라벨 수신
3) 음식명 기반 규칙 엔진으로 노화 지수 계산 후 저장/응답
4) RN은 JSON 응답 렌더링

> 프론트 전용 개발 단계에서는 1)~4) 중 1)과 4)만 실제 구현 대상으로 삼고, 2)~3)은 Mock Layer로 대체합니다.

### 9. API 명세 (초안)

POST /api/v1/food/analyze (multipart/form-data)
- Part image: File
- 200 응답 예시
{
  "analyzedFoodName": "후라이드 치킨",
  "agingScore": 8,
  "agingUnit": "시간",
  "message": "바삭함 뒤에 숨겨진 시간의 습격! 내일은 젊어지는 음식을 먹어봐요.",
  "logId": 123
}
- 400 응답 예시
{
  "errorCode": "INVALID_IMAGE_FILE",
  "errorMessage": "분석할 수 없는 이미지 파일입니다."
}

### 10. 데이터 모델 (초안)

FoodLog
- id: Long (PK)
- userId: Long (MVP 고정 1)
- foodName: String
- agingScore: Int (시간)
- message: String
- imageUrl: String(optional)
- createdAt: LocalDateTime

### 11. 마일스톤

Phase 1: 백엔드 기초 (프로젝트 생성, DB 설정, Entity/Repo)
Phase 2: Vision 연동, 규칙 엔진, 컨트롤러
Phase 3: RN 프로젝트, 라이브러리 설치, 화면 구조
Phase 4: 촬영/갤러리→API 호출→결과 화면 연동

### 12. 리스크 & 가드레일

- Vision 라벨링 모호성: 후보 상위 N개 중 룰 매칭, 실패 시 사용자 입력 fallback
- 규칙 오남용: 유머러스한 톤 유지, 의학적 사실 아님 명시
- 성능 편차: 이미지 압축/리사이즈로 업로드 최적화
- 개인 정보: 이미지 저장 기본 비활성, 저장 시 사전 고지/동의


